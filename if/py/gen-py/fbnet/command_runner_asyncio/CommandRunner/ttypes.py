#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import fb303_asyncio.fb303.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'FBNetDataException', 'UnsupportedDeviceException', 'SessionException', 'UnsupportedCommandException', 'InstanceOverloaded', 'Device', 'CommandResult', 'Session']

class FBNetDataException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FBNetDataException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UnsupportedDeviceException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UnsupportedDeviceException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SessionException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SessionException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UnsupportedCommandException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UnsupportedCommandException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class InstanceOverloaded(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InstanceOverloaded')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Device:
  """
  Attributes:
   - hostname
   - username
   - password
   - console
   - mgmt_ip
   - command_prompts
   - ip_address
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hostname = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.username = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.password = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.console = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.mgmt_ip = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.MAP:
          self.command_prompts = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _key5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.command_prompts[_key5] = _val6
          else: 
            while iprot.peekMap():
              _key7 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val8 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.command_prompts[_key7] = _val8
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.ip_address = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.hostname == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'hostname' was not found in serialized data! Struct: Device")

    if self.username == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'username' was not found in serialized data! Struct: Device")

    if self.password == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'password' was not found in serialized data! Struct: Device")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Device')
    if self.hostname != None:
      oprot.writeFieldBegin('hostname', TType.STRING, 1)
      oprot.writeString(self.hostname.encode('utf-8')) if UTF8STRINGS and not isinstance(self.hostname, bytes) else oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 10)
      oprot.writeString(self.username.encode('utf-8')) if UTF8STRINGS and not isinstance(self.username, bytes) else oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 11)
      oprot.writeString(self.password.encode('utf-8')) if UTF8STRINGS and not isinstance(self.password, bytes) else oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.console != None and self.console != self.thrift_spec[13][4]:
      oprot.writeFieldBegin('console', TType.STRING, 13)
      oprot.writeString(self.console.encode('utf-8')) if UTF8STRINGS and not isinstance(self.console, bytes) else oprot.writeString(self.console)
      oprot.writeFieldEnd()
    if self.mgmt_ip != None and self.mgmt_ip != self.thrift_spec[14][4]:
      oprot.writeFieldBegin('mgmt_ip', TType.BOOL, 14)
      oprot.writeBool(self.mgmt_ip)
      oprot.writeFieldEnd()
    if self.command_prompts != None:
      oprot.writeFieldBegin('command_prompts', TType.MAP, 15)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.command_prompts))
      for kiter9,viter10 in self.command_prompts.items():
        oprot.writeString(kiter9.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter9, bytes) else oprot.writeString(kiter9)
        oprot.writeString(viter10.encode('utf-8')) if UTF8STRINGS and not isinstance(viter10, bytes) else oprot.writeString(viter10)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ip_address != None:
      oprot.writeFieldBegin('ip_address', TType.STRING, 16)
      oprot.writeString(self.ip_address.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ip_address, bytes) else oprot.writeString(self.ip_address)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.hostname, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    hostname=%s' % (value))
    value = pprint.pformat(self.username, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    username=%s' % (value))
    value = pprint.pformat(self.password, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    password=%s' % (value))
    value = pprint.pformat(self.console, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    console=%s' % (value))
    value = pprint.pformat(self.mgmt_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    mgmt_ip=%s' % (value))
    value = pprint.pformat(self.command_prompts, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    command_prompts=%s' % (value))
    value = pprint.pformat(self.ip_address, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ip_address=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CommandResult:
  """
  Attributes:
   - output
   - status
   - command
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.output = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.status = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.output == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'output' was not found in serialized data! Struct: CommandResult")

    if self.status == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'status' was not found in serialized data! Struct: CommandResult")

    if self.command == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'command' was not found in serialized data! Struct: CommandResult")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CommandResult')
    if self.output != None:
      oprot.writeFieldBegin('output', TType.STRING, 1)
      oprot.writeString(self.output.encode('utf-8')) if UTF8STRINGS and not isinstance(self.output, bytes) else oprot.writeString(self.output)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 2)
      oprot.writeString(self.status.encode('utf-8')) if UTF8STRINGS and not isinstance(self.status, bytes) else oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 3)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.output, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    output=%s' % (value))
    value = pprint.pformat(self.status, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    status=%s' % (value))
    value = pprint.pformat(self.command, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    command=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Session:
  """
  Attributes:
   - id
   - name
   - hostname
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hostname = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'id' was not found in serialized data! Struct: Session")

    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: Session")

    if self.hostname == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'hostname' was not found in serialized data! Struct: Session")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Session')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.hostname != None:
      oprot.writeFieldBegin('hostname', TType.STRING, 3)
      oprot.writeString(self.hostname.encode('utf-8')) if UTF8STRINGS and not isinstance(self.hostname, bytes) else oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.id, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    id=%s' % (value))
    value = pprint.pformat(self.name, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    name=%s' % (value))
    value = pprint.pformat(self.hostname, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    hostname=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(FBNetDataException)
FBNetDataException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

FBNetDataException.thrift_struct_annotations = {
}
FBNetDataException.thrift_field_annotations = {
}

def FBNetDataException__init__(self, message=None,):
  self.message = message

FBNetDataException.__init__ = FBNetDataException__init__

all_structs.append(UnsupportedDeviceException)
UnsupportedDeviceException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

UnsupportedDeviceException.thrift_struct_annotations = {
}
UnsupportedDeviceException.thrift_field_annotations = {
}

def UnsupportedDeviceException__init__(self, message=None,):
  self.message = message

UnsupportedDeviceException.__init__ = UnsupportedDeviceException__init__

all_structs.append(SessionException)
SessionException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

SessionException.thrift_struct_annotations = {
}
SessionException.thrift_field_annotations = {
}

def SessionException__init__(self, message=None,):
  self.message = message

SessionException.__init__ = SessionException__init__

all_structs.append(UnsupportedCommandException)
UnsupportedCommandException.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

UnsupportedCommandException.thrift_struct_annotations = {
}
UnsupportedCommandException.thrift_field_annotations = {
}

def UnsupportedCommandException__init__(self, message=None,):
  self.message = message

UnsupportedCommandException.__init__ = UnsupportedCommandException__init__

all_structs.append(InstanceOverloaded)
InstanceOverloaded.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

InstanceOverloaded.thrift_struct_annotations = {
}
InstanceOverloaded.thrift_field_annotations = {
}

def InstanceOverloaded__init__(self, message=None,):
  self.message = message

InstanceOverloaded.__init__ = InstanceOverloaded__init__

all_structs.append(Device)
Device.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'hostname', True, None, 0, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'username', True, None, 0, ), # 10
  (11, TType.STRING, 'password', True, None, 0, ), # 11
  None, # 12
  (13, TType.STRING, 'console', True, "", 1, ), # 13
  (14, TType.BOOL, 'mgmt_ip', None, False, 1, ), # 14
  (15, TType.MAP, 'command_prompts', (TType.STRING,True,TType.STRING,True), None, 1, ), # 15
  (16, TType.STRING, 'ip_address', True, None, 1, ), # 16
)

Device.thrift_struct_annotations = {
}
Device.thrift_field_annotations = {
}

def Device__init__(self, hostname=None, username=None, password=None, console=Device.thrift_spec[13][4], mgmt_ip=Device.thrift_spec[14][4], command_prompts=None, ip_address=None,):
  self.hostname = hostname
  self.username = username
  self.password = password
  self.console = console
  self.mgmt_ip = mgmt_ip
  self.command_prompts = command_prompts
  self.ip_address = ip_address

Device.__init__ = Device__init__

all_structs.append(CommandResult)
CommandResult.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'output', True, None, 0, ), # 1
  (2, TType.STRING, 'status', True, None, 0, ), # 2
  (3, TType.STRING, 'command', True, None, 0, ), # 3
)

CommandResult.thrift_struct_annotations = {
}
CommandResult.thrift_field_annotations = {
}

def CommandResult__init__(self, output=None, status=None, command=None,):
  self.output = output
  self.status = status
  self.command = command

CommandResult.__init__ = CommandResult__init__

all_structs.append(Session)
Session.thrift_spec = (
  None, # 0
  (1, TType.I64, 'id', None, None, 0, ), # 1
  (2, TType.STRING, 'name', True, None, 0, ), # 2
  (3, TType.STRING, 'hostname', True, None, 0, ), # 3
)

Session.thrift_struct_annotations = {
}
Session.thrift_field_annotations = {
}

def Session__init__(self, id=None, name=None, hostname=None,):
  self.id = id
  self.name = name
  self.hostname = hostname

Session.__init__ = Session__init__

fix_spec(all_structs)
del all_structs
